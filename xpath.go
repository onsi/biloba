package biloba

import (
	"fmt"
	"strings"
)

/*
Type XPath allows you to provide an XPath query anywhere Biloba accepts a selector

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
type XPath string

/*
XPath() constructs an XPath query - you can provide a fully specified query:

	tab.XPath("//div[@id='foo']")

or use the XPath DSL:

	tab.XPath("div").WithID("foo")

You then pass the result into one of Biloba's DOM methods/matchers:

	tab.Click(tab.XPath("div").WithID("foo"))
	Eventually(tab.XPath(".comment").WithText("Hello world")).Should(tab.Exist())

When invoked with no arguments tab.XPath() returns a new XPath query that begins with "//*" for example:

	tab.Click(tab.XPath().WithID("foo"))

will match any element with id 'foo'

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (b *Biloba) XPath(path ...string) XPath {
	if len(path) == 0 {
		return XPath("//*")
	}
	if strings.HasPrefix(path[0], "/") || strings.HasPrefix(path[0], "./") {
		return XPath(path[0])
	}
	return XPath("//" + path[0])
}

/*
RelativeXPath() begins a relative XPath query - one that begins with "./"

It is primarily used with [XPath.WithChildMatching]:

	b.XPath("ul").WithChildMatching(b.RelativeXPath("li").WithText("igloo"))

will select <ul> elements that have a child <li> with text igloo

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (b *Biloba) RelativeXPath(path ...string) XPath {
	if len(path) == 0 {
		return XPath("./*")
	}
	if strings.HasPrefix(path[0], "/") || strings.HasPrefix(path[0], "./") {
		return XPath(path[0])
	}
	return XPath("./" + path[0])
}

/*
XPredicate() returns an empty XPath snippet for use with boolean operations:

	b.XPath("button").WithText("Add Comment").Not(b.XPredicate().HasAttr("disabled"))

will match <button> elements containing text "Add Comment" that are not disabled.

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (b *Biloba) XPredicate() XPath {
	return XPath("")
}

func (x XPath) quote(in string) string {
	if !strings.Contains(in, `"`) {
		return `"` + in + `"`
	}
	components := strings.Split(in, `"`)
	b := &strings.Builder{}
	b.WriteString("concat(")
	for i, c := range components {
		b.WriteString(`"` + c + `"`)
		if i < len(components)-1 {
			b.WriteString(`,'"',`)
		}
	}
	b.WriteString(")")
	return b.String()
}

/*
String() renders the XPath generated by the DSL as a string.  This means you can just fmt.Print an XPath query to see what Biloba has generated

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) String() string {
	return string(x)
}

/*
HasAttr(attr) appends the [@attr] attribute existence predicate to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) HasAttr(attr string) XPath {
	return x + XPath("[@"+attr+"]")
}

/*
WithAttr(attr, value) appends the [@attr='value'] attribute predicate to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithAttr(attr string, value string) XPath {
	return x + XPath("[@"+attr+"="+x.quote(value)+"]")
}

/*
WithAttrStartsWith(attr, value) appends the [starts-with(@attr, 'value')] attribute predicate to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithAttrStartsWith(attr string, value string) XPath {
	return x + XPath("[starts-with(@"+attr+", "+x.quote(value)+")]")
}

/*
WithAttrContains(attr, value) appends the [contains(@attr, 'value')] attribute predicate to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithAttrContains(attr string, value string) XPath {
	return x + XPath("[contains(@"+attr+", "+x.quote(value)+")]")
}

/*
WithText(value) appends the [text()='value'] predicate to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithText(value string) XPath {
	return x + XPath("[text()="+x.quote(value)+"]")
}

/*
WithTextStartsWith(value) appends the [starts-with(text(), 'value')] predicate to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithTextStartsWith(value string) XPath {
	return x + XPath("[starts-with(text(), "+x.quote(value)+")]")
}

/*
WithTextContains(value) appends the [contains(text(), 'value')] predicate to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithTextContains(value string) XPath {
	return x + XPath("[contains(text(), "+x.quote(value)+")]")
}

/*
WithID(id) appends [@id='id'] to the XPath

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithID(id string) XPath {
	return x.WithAttr("id", id)
}

/*
WithClass(call) appends a class predicate to the XPath.  See https://devhints.io/xpath for details

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithClass(class string) XPath {
	return x + XPath("[contains(concat(' ',normalize-space(@class),' '),"+x.quote(" "+class+" ")+")]")
}

/*
Not() takes an XPredicate() and negates it, then appends that predicate the XPath query:

	tab.XPath().Not(tab.XPredicate().WithClass("hidden"))

will select all elements that do not have class hidden

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Not(predicate XPath) XPath {
	predicateContent := predicate[1 : len(predicate)-1]
	return x + XPath("[not("+predicateContent+")]")
}

/*
Or() takes arbitrarily many XPredicate() and ORs them together, then appends that predicate the XPath query:

	tab.XPath().Or(Not(tab.XPredicate().WithClass("hidden")), tab.XPredicate().WithClass("important"))

will select all elements that do not have class hidden or have class important.

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Or(predicates ...XPath) XPath {
	predicateContents := []string{}
	for _, predicate := range predicates {
		predicateContents = append(predicateContents, string("("+predicate[1:len(predicate)-1]+")"))
	}
	return x + XPath("["+strings.Join(predicateContents, " or ")+"]")
}

/*
And() takes arbitrarily many XPredicate() and ANDs them together, then appends that predicate the XPath query.

	tab.XPath().And(tab.XPredicate().WithClass("hidden"), tab.XPredicate().WithClass("important"))

will select all elements that have class hidden and class important.  Note that in most cases you should just:

	tab.XPath().WithClass("hidden").WithClass("important")

And() is necessary if you want to nest boolean operations:

	tab.XPath().Or(
		Not(tab.XPredicate().WithClass("hidden")),
		And(
			tab.XPredicate().WithClass("important"),
			tab.XPredicate().WithClass("top-secret"),
		),
	)

will select all elements that do not have class hidden or elements that have both important and top-secret.

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) And(predicates ...XPath) XPath {
	predicateContents := []string{}
	for _, predicate := range predicates {
		predicateContents = append(predicateContents, string("("+predicate[1:len(predicate)-1]+")"))
	}
	return x + XPath("["+strings.Join(predicateContents, " and ")+"]")
}

/*
Child() adds the child axis to the XPath query.  Child() appends "/*" and Child(tag) appends "/tag"

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Child(tag ...string) XPath {
	if len(tag) == 0 {
		return x + XPath("/*")
	}
	return x + XPath("/"+tag[0])
}

/*
Parent() appends the direct parent axis "/.." to the XPath query

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Parent() XPath {
	return x + XPath("/..")
}

/*
Descendant() appends the descendant axis to the XPath query.  Descendant() appends "//*" while Descendant(tag) appends "//tag"

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Descendant(tag ...string) XPath {
	if len(tag) == 0 {
		return x + XPath("//*")
	}
	return x + XPath("//"+tag[0])
}

/*
Ancestor() appends the ancestor-or-self axis to the XPath query.  Ancestor() appends "/ancestor-or-self::*" while Ancestor(tag) appends "/ancestor-or-self::tag"

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Ancestor(tag ...string) XPath {
	if len(tag) == 0 {
		return x + XPath("/ancestor-or-self::*")
	}
	return x + XPath("/ancestor-or-self::"+tag[0])
}

/*
DescendantNotSelf() appends the descendant axis to the XPath query.  DescendantNotSelf() appends "/descendant::*" while DescendantNotSelf(tag) appends "/descendant::tag"

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) DescendantNotSelf(tag ...string) XPath {
	if len(tag) == 0 {
		return x + XPath("/descendant::*")
	}
	return x + XPath("/descendant::"+tag[0])
}

/*
AncestorNotSelf() appends the ancestor axis to the XPath query.  AncestorNotSelf() appends "/ancestor::*" while AncestorNotSelf(tag) appends "/ancestor::tag"

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) AncestorNotSelf(tag ...string) XPath {
	if len(tag) == 0 {
		return x + XPath("/ancestor::*")
	}
	return x + XPath("/ancestor::"+tag[0])
}

/*
FollowingSibling() appends the following-sibling axis to the XPath query.  FollowingSibling() appends "/following-sibling::*" while FollowingSibling(tag) appends "/following-sibling::tag"

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) FollowingSibling(tag ...string) XPath {
	if len(tag) == 0 {
		return x + XPath("/following-sibling::*")
	}
	return x + XPath("/following-sibling::"+tag[0])
}

/*
PrecedingSibling() appends the preceding-sibling axis to the XPath query.  PrecedingSibling() appends "/preceding-sibling::*" while PrecedingSibling(tag) appends "/preceding-sibling::tag"

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) PrecedingSibling(tag ...string) XPath {
	if len(tag) == 0 {
		return x + XPath("/preceding-sibling::*")
	}
	return x + XPath("/preceding-sibling::"+tag[0])
}

/*
WithChildMatching() takes a RelativeXPath() and adds it as a predicate to the XPath query:

	b.XPath("ul").WithChildMatching(b.RelativeXPath("li").WithText("igloo"))

will select <ul> elements that have a child <li> with text igloo

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) WithChildMatching(childPath XPath) XPath {
	return x + "[" + childPath + "]"
}

/*
First() adds the index selection predicate [1] to the XPath query to select the first matching element

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) First() XPath {
	return x + XPath("[1]")
}

/*
Nth(n) adds the index selection predicate [n] to the XPath query to select the nth matching element

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Nth(n int) XPath {
	return x + XPath(fmt.Sprintf("[%d]", n))
}

/*
Last(n) adds the index selection predicate [last()] to the XPath query to select the last matching element

Read https://onsi.github.io/biloba/#the-xpath-dsl to learn more about Biloba's XPath DSL
*/
func (x XPath) Last() XPath {
	return x + XPath("[last()]")
}
